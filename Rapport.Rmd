---
title: "Rapport"
author: "Ai-Ling Nguyen Bonnet & Elena Roques"
date: "2023-12-09"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(visdat)
library(reshape2)
library(ggplot2)
library(corrplot)
library(GGally)
library(factoextra)
library(pheatmap)
library(dplyr)
#library(outliers)
library(purrr)
library(mice)
library(tidyr)
```

# Biostatistique : Etude du diabète

### Ai-Ling Nguyen Bonnet & Eléna Roques

Nous allons au cours de ce travail construire un modèle de prédiction du diabète à partir d'un jeu de données du NIDDK.

```{r}
data <- read.csv('diabetes.csv')
print(data, row.names=F)
```
Le jeu de données contient le diagnostic (diabétique ou non) ainsi que la mesure de 8 autres variables (âge, IMC, nombre de grossesses, pression...) sur un ensemble de 768 femmes.

##### Question 0 - Prétraitement des données

On a remarqué ci-dessus que certaines données étaient manquantes (matérialisées par NA dans le data-frame).

On commence par regarder la quantité et la répartition de ces données manquantes :

```{r Données manquantes}
summary(data) #donne le nombre de NA par variable
vis_miss(data[,-1]) #graphe de répartition des NA par variable ; % de NA global et par variable
md.pattern(data, rotate.names=TRUE) #visualisation des NA par entrée ; entrées qui cumulent plusieurs NA
```
On remarque qu'effectivement, les variables insulin et triceps présentent un grand nombre de données manquantes, respectivement presque la moitié (374/768) et un tiers (227/768) des entrées.
Les autres variables sont complètes où avec une faible proportion de NA (5% ou moins)
En tout, 9.4% des données sont manquantes. 

Certaines entrées cumulent une absence de données dans 2, 3 ou 4 variables différentes. 
Pour des raisons de cohérence des données, on décide d'écarter de la suite de l'étude celles où 3 ou 4 variables ne sont pas renseignées (soit 35 entrées).

```{r}
data$nb_NA <- apply(data, MARGIN = 1, function(x){sum(is.na(x))})
data_trie <- data |> subset(nb_NA < 3, select = - nb_NA)
```

On vérifie la répartition des NA restants : 
```{r}
vis_miss(data_trie)
md.pattern(data_trie, rotate.names=TRUE)
```
Il reste donc 7,4% de NA : la quasi-totalité concernent les variables insulin et triceps.

On va maintenant procéder à l'imputation des données pour données des valeurs à ces données manquantes. Pour cela on utilise le package MICE : Multivariate Imputation by Chained Equations. 

```{r}
data_impute=mice(data_trie, m=5) #construction des imputations = valeurs manquantes ; on le fait 5 fois
data_impute$meth #voir quelle méthode d'imputation a été utilisée pour chaque variable ; on peut spécifier si on veut utiliser une méthode en particulier
```
La méthode utlisée par défaut pour l'imputation des variables est le Predictive Mean Matching (pmm). C'est une méthode qui permet d'obtenir des données manquantes probables en les tirant aléatoirement du reste des données parmi celles qui sont le plus proche de la valeur prédites en fonction des autres variables.

On a réalisé 5 imputations différentes, on va maintenant les observer pour vérifier qu'elles sont bien cohérentes.
```{r}
densityplot(data_impute, auto.key=TRUE)
stripplot(data_impute, pressure + mass + glucose + triceps + insulin ~ .imp,cex = c(1.5), pch = c(20), jitter = TRUE, layout = c(5, 1))
```
Les différentes imputations correspondent raisonnablement aux données. 
On complète le jeu de données avec une des imputations et on vérifie que toutes les données manquantes ont été complétées.

```{r}
data = complete(data_impute, 1)
md.pattern(data, rotate.names=TRUE)
```

##### Question 1 - Analyse exploratoire des données
###1.1 - Distribution des variables
On va s'intéresser dans cette partie à la distribution des variables explicatives en fonction de la variable diabetes. 

On commence par regarder la moyenne et la variance de chaque variable en fonction du diagnostic de la patiente :
```{r Moyennes}
data %>%
  group_by(diabetes) %>%
  summarise_at( c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass","pedigree","age"),.f = list(mean = mean), na.rm = TRUE)
  #summarise_all(sd,na.rm = TRUE)
  #get_summary_stats(glucose, type = "mean_sd")
```
```{r Variances}
data %>%
  group_by(diabetes) %>%
  summarise_at( c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass","pedigree","age"),.f = list(sd = sd), na.rm = TRUE)
```

# Représentation des distributions
```{r, echo = TRUE, fig.align = 'center', fig.height = 7.5, fig.width = 7.5}
data2 <- melt(data, id = "diabetes") 
ggplot(data = data2, aes(x = diabetes, y = value, color = diabetes)) + 
  geom_boxplot(col = "black", show.legend = FALSE, outlier.colour = NA) + theme_bw() +
  geom_point(shape = 1, 
             position = position_jitterdodge(dodge.width = .6, 
                                             jitter.width = .8), 
             size = 1.8, alpha = 1, show.legend = FALSE) +
  facet_wrap(. ~ variable, scales = "free") +
  theme(strip.background = element_rect(colour = "black", fill = "white"),
        strip.text.x = element_text(size = 11),
        axis.text = element_text(size = 9), axis.title = element_text(size = 0),
        legend.position = "bottom") + xlab("") + ylab("") +
  scale_color_manual(values = c("springgreen4","firebrick3"))
```
# Test statistique
On a deux groupes selon le diagnostic du diabète: les négatifs, *neg*, et les positifs,*pos*, dont on voudrait regarder les différences de moyenne. # de moyenne ? on regarde pas que ça non ?
Pour cela, un test t de Student ou de Welch peut-être pertinent, pourvu que les conditions suivantes soient remplies:

1.  Indépendance des observations. Chaque sujet ne doit appartenir qu'à un seul groupe. Il n'y a aucun lien entre les observations de chaque groupe. C'est bien vérifié dans notre cas, puisque les observations ne peuvent avoir qu'un seul label *diabetes* (*pos* ou *neg*). Les observations sont faites sur des femmes différentes, supposées sans lien.
2.  Aucune valeur aberrante significative dans les deux groupes
3.  Normalité. les données pour chaque groupe devraient être distribuées approximativement normalement.

Le test de Student suppose que les variances entre les deux groupes sont similaires, ce qui n'est pas le cas du test de Welch.

# Valeurs aberrantes
On va commencer par observer les valeurs aberrantes pour chaque variable.
On ne considère pas les valeurs aberrantes sur l'age, la masse ou le nombre de grossesses car il peut y avoir des variables extrêmes en fonction du groupe d'étude qui ne seront pas des erreurs de mesure.
```{r Valeurs aberrantes}
# Variables à tester
variables_a_tester <- c("glucose", "pressure", "triceps", "insulin", "pedigree")

# Utiliser la fonction map() pour identifier les outliers pour chaque variable
outliers_list <- map(variables_a_tester, ~ data %>%
                        group_by(diabetes) %>%
                        identify_outliers(.x)%>%
                        mutate(variable = .x))

outliers_combined <- bind_rows(outliers_list, .id="Variables")%>%
  arrange(ID) %>%
  select(ID, variable,everything(), -c(Variables))%>%
  filter(is.extreme == TRUE) 
print(outliers_combined)

# Calculer le nombre de valeurs différentes dans la colonne "ID"
num_outliers <- outliers_combined %>%
  summarize(num_outliers= n_distinct(ID))

print(num_outliers)
```

Il y a 32 observations aberrantes extrêmes.
On construit un set de données "nettoyées" sans ces valeurs :
```{r}
data_clean<- anti_join(data, outliers_combined, by = "ID")
```

# Normalité par groupes

On vérifie, pour chaque variable, si les groupes de données suivent une loi normale.
On utilise à cet effet le test de Shapiro - Wilk.
Si la p-value est inférieure à 0.005, on considère que les données ne suivent pas une loi normale.

```{r Shapiro-Wilk test}
# Utiliser la fonction map() pour effectuer le test de Shapiro-Wilk sur chaque variable
shapiro_tests <- map(variables_a_tester, ~ data %>%
                      group_by(diabetes) %>%
                      summarise(p_value = shapiro.test(.[[.x]])$p.value) %>%
                      mutate(variable = .x)%>%
                      select(variable, diabetes, p_value))

# Combinez les résultats dans un tableau
shapiro_combine <- bind_rows(shapiro_tests)

# Afficher le tableau combiné
print(shapiro_combine)
```
La *p-value* est très faible pour tous les groupes donc on ne peut pas considérer que les données suivent une loi normale.

# t -test

Pour évaluer les différences entre les deux groupes *pos* et *neg* selon les variables, on utilise un test statistique.

Les données ne suivent pas une loi normale, donc le test de Welch ne peut pas être utilisé de façon rigoureuse.
On fait donc un test de Wilcoxon qui est une alternative non paramétrique à ces test t pour comparer des moyennes.
On s'autorise à faire le test de Welch pour comparer les résultats.

```{r Tests statistiques}
# Variables à tester
variables_a_tester <- c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass", "pedigree", "age")

# Le t-test classique - version par défaut de Welch
welch_tests <- map(variables_a_tester, ~ data_clean %>%
                    t_test(as.formula(paste(.x, "~ diabetes"))) %>%
                    add_significance())
welch_res <- bind_rows(welch_tests)%>% 
    select(-one_of("group1", "group2", "statistic","df"))%>%
    rename('Welch - p_value' = 'p', "Welch Signif" = 'p.signif')

# Le test de Wilcox pour des données non normalisées 
wilcox_tests <- map(variables_a_tester, ~ data_clean %>%
                    wilcox_test(as.formula(paste(.x, "~ diabetes"))) %>%
                    add_significance())
wilcox_res <- bind_rows(wilcox_tests)%>% 
    select(-one_of("group1", "group2", "statistic"))%>%
  rename('Wilcox - p_value' = 'p', "Wilcox Signif" = 'p.signif')

test_res <- left_join(welch_res, wilcox_res)
print(test_res)
```

Pour chaque variables, et quelque soit le test, la *p-value* est très faible (inférieure à 0.001) donc on peut rejeter l'hypothèse que les groupes *positifs* et *négatifs* ont la même moyenne.

Il est donc raisonnable de considérer que pour chaque variable, la différence entre les deux groupes est significative.

# 1.2 - Analyse en composante principale
On va maintenant séparer le jeu de données avec les variables explicatives d'un côté et l'étiquette (diagnostic du diabète) de l'autre. On enlève la colonne ID qui n'a pas d'interêt explicatif.

```{r Séparation variables-labels}
#On sépare les labels des variables 
X = data[,2:(NCOL(data)-1)]
y = data[, NCOL(data)]
y = factor(y, levels = c("neg", "pos"), labels = c(0, 1))
```

Les données sont normalisées et centrées au sein de la fonction pca.

```{r}
fit.pca <- prcomp(X, center = TRUE, scale = TRUE) #on construit le PCA en centrant (center) et normalisant (scale) les données

summary(fit.pca)
print(head(fit.pca$x))

fviz_screeplot(fit.pca, addlabels=TRUE)

indiv_pca <-fviz_pca_ind(fit.pca, habillage = data$diabetes) 
indiv_pca
# indiv_pca +
#   scale_color_manual(values = c("0" = "cyan", "1" = "red"),
#                      breaks = c(0, 1),
#                      labels = c("neg", "pos"),
#                      name = "Individuals - PCA")
#on peut l'enlever tout ça ?

fviz_pca_var(fit.pca, repel = TRUE)

fviz_pca_biplot(fit.pca, habillage = data$diabetes)
```
# Interprétation
L'analyse en composante principale permet de représenter les données dans un plan en deux dimension qui est fonction des huit variables étudiées.
Les deux premières composantes principales permettent d'expliquer 49,85% de la variance des données. 

Les variables les mieux représentées dans ces deux dimensions sont age et pregnant d'une part ; triceps et mass d'autre part (car longueur de la flèche proche de 1). Ces deux couples de variables semblent corrélés car les flèches correspondantes pointent dans la même direction.

On va regarder cela de plus près en affichant la matrice des corrélations : 

```{r}
corrplot(cor(X), type = "upper", addCoef.col = TRUE) #matrice des corrélations
help(corrplot)

ggpairs(data, columns = 2:(ncol(data)-1), ggplot2::aes(colour=diabetes), progress = FALSE)
```
On observe effectivement des corrélations >0,55 pour trois couples de variables dont les deux cités ci-dessus ainsi que glucose et insulin, mais ces corrélations ne sont pas très significatives.
Dans le cas de age et pregnant on peut l'interpréter de la façon suivante : une femme qui a été enceinte de nombreuses fois est probablement âgée, mais une femme qui n'a jamais été enceinte n'est pas forcément jeune, d'où le fait que la corrélation ne soit pas très forte.

##### Question 2 - Prédiction par régression logistique
### 2.1 Régression logistique

**Faire une base test indépendante** ie séparer les données en deux sets : training_data et test_data.
Par ex 80% et 20% des données exploitables.

Pour réaliser une régression logistique, il est nécessaire d'avoir un **nombre suffisant de données**.
En pratique, il est recommandé d'avoir au moins **10 fois plus d'événements que de paramètres dans le modèle**.
Ici, on a des plusieurs centaines d'observations (pour chaque label), pour huit paramètres donc il y a suffisamment de données.

```{r Base test indépendante}
nb_obs = NROW(data)
cut = round(0.8*nb_obs)
training_X = X[1:cut,]
training_y = y[1:cut]
test_X = X[cut+1:nb_obs,]
test_y = y[cut+1:nb_obs]

data <- read.csv('diabetes.csv')
data <- na.omit(data)
#data <- mutate(data, diabetes = ifelse(diabetes == "neg", int(0), ifelse(diabetes == "pos", numeric(1), diabetes)))
data$diabetes = factor(data$diabetes, levels = c("neg", "pos"), labels = c(0, 1))
training_data = data[1:cut,2:NCOL(data)]
test_data = data[cut+1: nb_obs,2:NCOL(data)]

print(training_data)
```

```{r Régression logistique}

# X ne contient pas les ID qui ne sont pas une variable explicative 
model <- glm(diabetes ~ pregnant +glucose + pressure + triceps + insulin + mass + pedigree + age, data = training_data, family = "binomial")
model_res <- summary(model)

# Obtenir l'ordre des indices des coefficients en ordre décroissant
order_indices <- order(abs(model_res$coefficients[, 1]), decreasing = TRUE)

# Afficher le résumé avec les coefficients triés
model_res$coefficients <- model_res$coefficients[order_indices, ]
print(model_res)
```

Modèle que l'on obtient

$$
diabete = 0.11*pregnant + 0.036*glucose + 0.0013*pressure + 0.0066*triceps - 9*10^{-4}*insulin + 0.085*mass + 1.2*pedigree + 0.029*age - 10.2 
$$

ie les coefficients estimés pour chaque variables + l'intercept (ordonnée à l'orgine).

```{r}
coefficients <- coef(model)

# Créer un dataframe pour les coefficients
coefficients_df <- data.frame(variable = names(coefficients), coefficient = coefficients)

print(coefficients_df)

# Tracer le graphique des coefficients
ggplot(coefficients_df, aes(x = variable, y = coefficient)) +
  geom_bar(stat = "identity", fill = "blue", alpha = 0.7) +
  labs(title = "Graphique des Coefficients", x = "Variables", y = "Coefficient")
```

On pourrait regarder les *odd ratios* OR qui représentent l'influence d'un paramètre --\> A creuser ...

```{r}
library(questionr)
odds.ratio(model)
```

```{r}
#install.packages("broom.helpers")
ggcoef_model(model, exponentiate = TRUE)
```

```{r}
install.packages("effects")
library(effects)
plot(allEffects(model))
```

### 2.2. Calculs
### 2.3. Pénalité ℓ1 + ℓ2.
### 2.4. Modèle de régression logistique pénalisée ℓ1 +ℓ2

pour prédire la variable diabetes à partir de l'ensemble des facteurs de risque.
Quelles variables semblent les plus pertinentes ?
Reporter les indicateurs de qualités de cette régression logistique pénalisée ℓ1 + ℓ2.

Remarque 1.
Vous veillerez à optimiser les paramètres de ce modèle par cross-validation.

Remarque 2.
En utilisant l'argument weights de la fonction glmnet(), il est possible de gérer le déséquilibre des classes.

### 2.5. Comparaison avec la selection de variable pas - à - pas

Comparer vos résultats issus de la régression logistique pénalisée ℓ1 + ℓ2 au résultat d'une méthode de

sélection de variables pas-à-pas (step() en R).

### 2.6. Conclusion
