---
title: "Rapport"
author: "Ai-Ling Nguyen Bonnet & Elena Roques"
date: "2023-12-09"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(visdat)
library(reshape2)
library(ggplot2)
library(corrplot)
library(GGally)
library(factoextra)
library(pheatmap)
library(dplyr)
#library(outliers)
library(purrr)
library(mice)
library(tidyr)
```

# Biostatistique : Etude du diabète

### Ai-Ling Nguyen Bonnet & Eléna Roques

Nous allons au cours de ce travail construire un modèle de prédiction du diabète à partir d'un jeu de données du NIDDK.

```{r}
data <- read.csv('diabetes.csv')
print(data, row.names=F)
```
Le jeu de données contient le diagnostic (diabétique ou non) ainsi que la mesure de 8 autres variables (âge, IMC, nombre de grossesses, pression...) sur un ensemble de 768 femmes.

##### Question 0 - Prétraitement des données

On a remarqué ci-dessus que certaines données étaient manquantes (matérialisées par NA dans le data-frame).

On commence par regarder la quantité et la répartition de ces données manquantes :

```{r Données manquantes}
summary(data) #donne le nombre de NA par variable
vis_miss(data[,-1]) #graphe de répartition des NA par variable ; % de NA global et par variable
md.pattern(data, rotate.names=TRUE) #visualisation des NA par entrée ; entrées qui cumulent plusieurs NA
```
On remarque qu'effectivement, les variables insulin et triceps présentent un grand nombre de données manquantes, respectivement presque la moitié (374/768) et un tiers (227/768) des entrées.
Les autres variables sont complètes où avec une faible proportion de NA (5% ou moins)
En tout, 9.4% des données sont manquantes. 

Certaines entrées cumulent une absence de données dans 2, 3 ou 4 variables différentes. 
Pour des raisons de cohérence des données, on décide d'écarter de la suite de l'étude celles où 3 ou 4 variables ne sont pas renseignées (soit 35 entrées).

```{r}
data$nb_NA <- apply(data, MARGIN = 1, function(x){sum(is.na(x))})
data_trie <- data |> subset(nb_NA < 3, select = - nb_NA)
```

On vérifie la répartition des NA restants : 
```{r}
vis_miss(data_trie)
md.pattern(data_trie, rotate.names=TRUE)
```
Il reste donc 7,4% de NA : la quasi-totalité concernent les variables insulin et triceps.

On va maintenant procéder à l'imputation des données pour données des valeurs à ces données manquantes. Pour cela on utilise le package MICE : Multivariate Imputation by Chained Equations. 

```{r}
data_impute=mice(data_trie, m=5) #construction des imputations = valeurs manquantes ; on le fait 5 fois
data_impute$meth #voir quelle méthode d'imputation a été utilisée pour chaque variable ; on peut spécifier si on veut utiliser une méthode en particulier
```
La méthode utlisée par défaut pour l'imputation des variables est le Predictive Mean Matching (pmm). C'est une méthode qui permet d'obtenir des données manquantes probables en les tirant aléatoirement du reste des données parmi celles qui sont le plus proche de la valeur prédites en fonction des autres variables.

On a réalisé 5 imputations différentes, on va maintenant les observer pour vérifier qu'elles sont bien cohérentes.
```{r}
densityplot(data_impute, auto.key=TRUE)
stripplot(data_impute, pressure + mass + glucose + triceps + insulin ~ .imp,cex = c(1.5), pch = c(20), jitter = TRUE, layout = c(5, 1))
```
Les différentes imputations correspondent raisonnablement aux données. 
On complète le jeu de données avec une des imputations et on vérifie que toutes les données manquantes ont été complétées.

```{r}
data = complete(data_impute, 1)
md.pattern(data, rotate.names=TRUE)
```

ce truc dessous on peut le bouger à plus tard non ?
```{r}
#On sépare les labels des variables 
X = data[,2:(NCOL(data)-1)]
y = data[, NCOL(data)]
y = factor(y, levels = c("neg", "pos"), labels = c(0, 1))
print(typeof(y))
```


##### Question 1 - Analyse exploratoire des données

###1.1 - Distribution des variables

1.1.
Représenter la distribution de chaque variable explicative conditionnée par la variable diabetes. Observe-t-on des différences significatives ? En utilisant les tests statistiques qui conviennent (test de student, test du χ2, . . . ), vous justifierez soigneusement vos réponses en vous appuyant sur des critères de p-value ou autre intervalle de confiance.
(Dans toute la suite, vous travaillerez sur les données standardisées)




```{r Moyennes}
data %>%
  group_by(diabetes) %>%
  summarise_at( c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass","pedigree","age"),.f = list(mean = mean), na.rm = TRUE)
  #summarise_all(sd,na.rm = TRUE)
  #get_summary_stats(glucose, type = "mean_sd")
```

```{r Variances}
data %>%
  group_by(diabetes) %>%
  summarise_at( c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass","pedigree","age"),.f = list(sd = sd), na.rm = TRUE)
```

### Représentation des distributions

```{r, echo = TRUE, fig.align = 'center', fig.height = 7.5, fig.width = 7.5}
data2 <- melt(data, id = "diabetes") 
ggplot(data = data2, aes(x = diabetes, y = value, color = diabetes)) + 
  geom_boxplot(col = "black", show.legend = FALSE, outlier.colour = NA) + theme_bw() +
  geom_point(shape = 1, 
             position = position_jitterdodge(dodge.width = .6, 
                                             jitter.width = .8), 
             size = 1.8, alpha = 1, show.legend = FALSE) +
  facet_wrap(. ~ variable, scales = "free") +
  theme(strip.background = element_rect(colour = "black", fill = "white"),
        strip.text.x = element_text(size = 11),
        axis.text = element_text(size = 9), axis.title = element_text(size = 0),
        legend.position = "bottom") + xlab("") + ylab("") +
  scale_color_manual(values = c("springgreen4","firebrick3"))
```

### Test statistique

On a deux groupes selon le diabète: les négatifs, *neg*, et les positifs,*pos*, dont on voudrait regarder les différences de moyenne.
Pour cela, un test t de Student ou de Welch peut-être pertinent, pourvu que les conditions suivantes soient remplies:

1.  Indépendance des observations. Chaque sujet ne doit appartenir qu'à un seul groupe. Il n'y a aucun lien entre les observations de chaque groupe. C'est bien vérifié dans notre cas, puisque les observations ne peuvent avoir qu'un seul label *diabetes* (*pos* ou *neg*). Les observations sont faites sur des femmes différentes, supposées sans lien.
2.  Aucune valeur aberrante significative dans les deux groupes
3.  Normalité. les données pour chaque groupe devraient être distribuées approximativement normalement.

Le test de Student suppose que les variances entre les deux groupes sont similaires, ce qui n'est pas le cas du test de Welch.

#### Valeurs aberrantes

```{r Valeurs aberrantes}
# Variables à tester
variables_a_tester <- c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass", "pedigree", "age")

# Utiliser la fonction map() pour identifier les outliers pour chaque variable
outliers_list <- map(variables_a_tester, ~ data %>%
                        group_by(diabetes) %>%
                        identify_outliers(.x)%>%
                        mutate(variable = .x))

outliers_combined <- bind_rows(outliers_list, .id="Variables")%>%
  arrange(ID) %>%
  select(ID, variable,everything(), -c(Variables))%>%
  filter(is.extreme == TRUE) 
print(outliers_combined)

# Calculer le nombre de valeurs différentes dans la colonne "ID"
num_outliers <- outliers_combined %>%
  summarize(num_outliers= n_distinct(ID))

print(num_outliers)
```

Il y a 19 observations aberrantes extrêmes.
On les enlèvera de *data*.
On peut considérer qu'il n'y pas de valeurs aberrantes sur l'age ou la masse + le nombre de grossesse car ces variables n'ont pas forcément une distribution normale.

#### **Normalité par groupes**

On vérifie, pour chaque variable, si les groupes de données suivent une loi normale.
On utilise à cet effet le test de Shapiro - Wilk.
Si la p-value est inférieure à 0.005, on considère que les données ne suivent pas une loi normale.

```{r Shapiro-Wilk test}


# Utiliser la fonction map() pour effectuer le test de Shapiro-Wilk sur chaque variable
shapiro_tests <- map(variables_a_tester, ~ data %>%
                      group_by(diabetes) %>%
                      summarise(p_value = shapiro.test(.[[.x]])$p.value) %>%
                      mutate(variable = .x)%>%
                      select(variable, diabetes, p_value))

# Combinez les résultats dans un tableau
shapiro_combine <- bind_rows(shapiro_tests)

# Afficher le tableau combiné
print(shapiro_combine)
```

La *p-value* est très faible pour tous les groupes donc on ne peut pas considérer de façon sûre que les données suivent une loi normale.

#### t -test

Pour évaluer les différences entre les deux groupes *pos* et *neg* selon les variables, on utilise un test statistique.

Les données ne suivent pas une loi normale, donc le test de Welch ne peut pas être utilisé de façon rigoureuse.
On fait donc un test de Wilcoxon qui est une alternative non paramétrique à ces test t pour comparer des moyennes.
On s'autorise à faire le test de Welch pour comparer les résultats.

```{r Tests statistiques}
# Variables à tester
data_clean<- anti_join(data, outliers_combined, by = "ID")
variables_a_tester <- c("pregnant", "glucose", "pressure", "triceps", "insulin", "mass", "pedigree", "age")

# Le t-test classique - version par défaut de Welch
welch_tests <- map(variables_a_tester, ~ data_clean %>%
                    t_test(as.formula(paste(.x, "~ diabetes"))) %>%
                    add_significance())
welch_res <- bind_rows(welch_tests)%>% 
    select(-one_of("group1", "group2", "statistic","df"))%>%
    rename('Welch - p_value' = 'p', "Welch Signif" = 'p.signif')


# Le test de Wilcox pour des données non normalisées 
wilcox_tests <- map(variables_a_tester, ~ data_clean %>%
                    wilcox_test(as.formula(paste(.x, "~ diabetes"))) %>%
                    add_significance())
wilcox_res <- bind_rows(wilcox_tests)%>% 
    select(-one_of("group1", "group2", "statistic"))%>%
  rename('Wilcox - p_value' = 'p', "Wilcox Signif" = 'p.signif')

test_res <- left_join(welch_res, wilcox_res)
print(test_res)
```

Pour chaque variables, et quelque soit le test, la *p-value* est très faible (inférieure à 0.001) donc on peut rejeter l'hypothèse que les groupes *positifs* et *négatifs* ont la même moyenne.

Il est donc raisonnable de considérer que pour chaque variable, la différence entre les deux groupes est significative.

## 1.2 - Analyse en composante principale

On fait l'analyse en enlevant les valeurs NA.
[Voir question 0 pour remplacer les NA par des valeurs numériques].
On enlève la colonne ID qui n'a pas d'interêt explicatif.
Les données sont normalisées et centrées au sein de la fonction pca.

```{r, echo = TRUE, fig.align = 'center', fig.height = 5.5, fig.width = 5.5}
fit.pca <- prcomp(X, center = TRUE, scale = TRUE)
```

```{r}
summary(fit.pca)
```

```{r}
print(head(fit.pca$x))
```

```{r}
fviz_screeplot(fit.pca, addlabels=TRUE)
```

```{r}
indiv_pca <-fviz_pca_ind(fit.pca, habillage = data$diabetes) 
indiv_pca
# indiv_pca +
#   scale_color_manual(values = c("0" = "cyan", "1" = "red"),
#                      breaks = c(0, 1),
#                      labels = c("neg", "pos"),
#                      name = "Individuals - PCA")
```

```{r}
fviz_pca_var(fit.pca, repel = TRUE)
```

```{r}
fviz_pca_biplot(fit.pca, habillage = data$diabetes)
```

### Interprétation

##### Question 2 - Prédiction par régression logistique

## 2.1 Régression logistique

**Faire une base test indépendante** ie séparer les données en deux sets : training_data et test_data.
Par ex 80% et 20% des données exploitables.

Pour réaliser une régression logistique, il est nécessaire d'avoir un **nombre suffisant de données**.
En pratique, il est recommandé d'avoir au moins **10 fois plus d'événements que de paramètres dans le modèle**.
Ici, on a des centaines d'observations (pour chaque label), pour moins de 10 paramètres donc il y a suffisamment de données.

```{r Base test indépendante}
nb_obs = NROW(data)
cut = round(0.8*nb_obs)
training_X = X[1:cut,]
training_y = y[1:cut]
test_X = X[cut+1:nb_obs,]
test_y = y[cut+1:nb_obs]

print(data)
data <- read.csv('diabetes.csv')
data <- na.omit(data)
#data <- mutate(data, diabetes = ifelse(diabetes == "neg", int(0), ifelse(diabetes == "pos", numeric(1), diabetes)))
data$diabetes = factor(data$diabetes, levels = c("neg", "pos"), labels = c(0, 1))
training_data = data[1:cut,2:NCOL(data)]
test_data = data[cut+1: nb_obs,2:NCOL(data)]

print(training_data)
```

```{r Régression logistique}

# X ne contient pas les ID qui ne sont pas une variable explicative 
model <- glm(diabetes ~ pregnant +glucose + pressure + triceps + insulin + mass + pedigree + age, data = training_data, family = "binomial")
model_res <- summary(model)

# Obtenir l'ordre des indices des coefficients en ordre décroissant
order_indices <- order(abs(model_res$coefficients[, 1]), decreasing = TRUE)

# Afficher le résumé avec les coefficients triés
model_res$coefficients <- model_res$coefficients[order_indices, ]
print(model_res)
```

Modèle que l'on obtient

$$
diabete = 0.11*pregnant + 0.036*glucose + 0.0013*pressure + 0.0066*triceps - 9*10^{-4}*insulin + 0.085*mass + 1.2*pedigree + 0.029*age - 10.2 
$$

ie les coefficients estimés pour chaque variables + l'intercept (ordonnée à l'orgine).

```{r}
coefficients <- coef(model)

# Créer un dataframe pour les coefficients
coefficients_df <- data.frame(variable = names(coefficients), coefficient = coefficients)

print(coefficients_df)

# Tracer le graphique des coefficients
ggplot(coefficients_df, aes(x = variable, y = coefficient)) +
  geom_bar(stat = "identity", fill = "blue", alpha = 0.7) +
  labs(title = "Graphique des Coefficients", x = "Variables", y = "Coefficient")
```

On pourrait regarder les *odd ratios* OR qui représentent l'influence d'un paramètre --\> A creuser ...

```{r}
library(questionr)
odds.ratio(model)
```

```{r}
#install.packages("broom.helpers")
ggcoef_model(model, exponentiate = TRUE)
```

```{r}
install.packages("effects")
library(effects)
plot(allEffects(model))
```

## 2.2. Calculs
## 2.3. Pénalité ℓ1 + ℓ2.
## 2.4. Modèle de régression logistique pénalisée ℓ1 +ℓ2

pour prédire la variable diabetes à partir de l'ensemble des facteurs de risque.
Quelles variables semblent les plus pertinentes ?
Reporter les indicateurs de qualités de cette régression logistique pénalisée ℓ1 + ℓ2.

Remarque 1.
Vous veillerez à optimiser les paramètres de ce modèle par cross-validation.

Remarque 2.
En utilisant l'argument weights de la fonction glmnet(), il est possible de gérer le déséquilibre des classes.

## 2.5. Comparaison avec la selection de variable pas - à - pas

Comparer vos résultats issus de la régression logistique pénalisée ℓ1 + ℓ2 au résultat d'une méthode de

sélection de variables pas-à-pas (step() en R).

## 2.6. Conclusion
